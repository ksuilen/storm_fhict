services:
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    environment:
      - APP_ENV=docker # Specifiek voor Docker runs
      # De volgende variabelen worden uit de .env file in de project root gehaald
      # door Docker Compose zelf, of uit de host environment als ze daar zijn gezet.
      # Pydantic in config.py zal ze dan uit de container's environment lezen.
      - SECRET_KEY=${SECRET_KEY:-}
      - TAVILY_API_KEY=${TAVILY_API_KEY:-}
      - OPENAI_API_KEY=${OPENAI_API_KEY:-}
      - STORM_RUNNER_VERSION=${STORM_RUNNER_VERSION:-v1}
      # Voeg hier andere env vars toe die je backend nodig heeft, bv:
      # - YDC_API_KEY=${YDC_API_KEY:-}
      # - BING_SEARCH_API_KEY=${BING_SEARCH_API_KEY:-}
      # etc.
    volumes:
      # Mount de map waarin de database komt
      - storm_db_data:/data/database # DB komt dan in /data/database/storm_app.db
      # Mount de map voor de output
      - storm_output_data:/data/storm_output
      # Mount voor Hugging Face model cache (persisteert models tussen rebuilds)
      - huggingface_cache:/root/.cache/huggingface
    restart: unless-stopped
    # environment:
    #   - PYTHONUNBUFFERED=1 # Goed voor direct zien van logs

  frontend:
    build:
      context: ./frontend/app
      dockerfile: Dockerfile
      args:
        - REACT_APP_API_URL_ARG=/api # Geef hier de waarde /api mee
    ports:
      - "${FRONTEND_PORT:-80}:80"
    depends_on:
      - backend
    # De environment sectie voor REACT_APP_API_URL is hier niet meer strikt nodig
    # voor de JS build, aangezien het nu via build args gaat.
    # environment:
    #   - REACT_APP_API_URL=/api 
    restart: unless-stopped

volumes:
  storm_db_data:
  storm_output_data:
  huggingface_cache: 